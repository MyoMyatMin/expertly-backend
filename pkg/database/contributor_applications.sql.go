// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: contributor_applications.sql

package database

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const applyContributorApplication = `-- name: ApplyContributorApplication :one
INSERT INTO contributor_applications(
    contri_app_id,
    user_id,
    expertise_proofs,
    identity_proof,
    initial_submission
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5
)
RETURNING contri_app_id, user_id, expertise_proofs, identity_proof, initial_submission, status, created_at, reviewed_at
`

type ApplyContributorApplicationParams struct {
	ContriAppID       uuid.UUID
	UserID            uuid.UUID
	ExpertiseProofs   []string
	IdentityProof     string
	InitialSubmission string
}

type ApplyContributorApplicationRow struct {
	ContriAppID       uuid.UUID
	UserID            uuid.UUID
	ExpertiseProofs   []string
	IdentityProof     string
	InitialSubmission string
	Status            sql.NullString
	CreatedAt         sql.NullTime
	ReviewedAt        sql.NullTime
}

func (q *Queries) ApplyContributorApplication(ctx context.Context, arg ApplyContributorApplicationParams) (ApplyContributorApplicationRow, error) {
	row := q.db.QueryRowContext(ctx, applyContributorApplication,
		arg.ContriAppID,
		arg.UserID,
		pq.Array(arg.ExpertiseProofs),
		arg.IdentityProof,
		arg.InitialSubmission,
	)
	var i ApplyContributorApplicationRow
	err := row.Scan(
		&i.ContriAppID,
		&i.UserID,
		pq.Array(&i.ExpertiseProofs),
		&i.IdentityProof,
		&i.InitialSubmission,
		&i.Status,
		&i.CreatedAt,
		&i.ReviewedAt,
	)
	return i, err
}

const getContributorApplication = `-- name: GetContributorApplication :one
SELECT 
    ca.contri_app_id,
    ca.user_id,
    ca.expertise_proofs,
    ca.identity_proof,
    ca.initial_submission,
    ca.status,
    ca.created_at,
    ca.reviewed_at,
    u.name AS name,
    u.username AS username,
    m.name AS reviewer_name
FROM contributor_applications ca
JOIN users u ON ca.user_id = u.user_id
LEFT JOIN moderators m ON ca.reviewed_by = m.moderator_id
WHERE ca.contri_app_id = $1
`

type GetContributorApplicationRow struct {
	ContriAppID       uuid.UUID
	UserID            uuid.UUID
	ExpertiseProofs   []string
	IdentityProof     string
	InitialSubmission string
	Status            sql.NullString
	CreatedAt         sql.NullTime
	ReviewedAt        sql.NullTime
	Name              string
	Username          string
	ReviewerName      sql.NullString
}

func (q *Queries) GetContributorApplication(ctx context.Context, contriAppID uuid.UUID) (GetContributorApplicationRow, error) {
	row := q.db.QueryRowContext(ctx, getContributorApplication, contriAppID)
	var i GetContributorApplicationRow
	err := row.Scan(
		&i.ContriAppID,
		&i.UserID,
		pq.Array(&i.ExpertiseProofs),
		&i.IdentityProof,
		&i.InitialSubmission,
		&i.Status,
		&i.CreatedAt,
		&i.ReviewedAt,
		&i.Name,
		&i.Username,
		&i.ReviewerName,
	)
	return i, err
}

const listContributorApplications = `-- name: ListContributorApplications :many
SELECT 
    ca.contri_app_id,
    ca.user_id,
    ca.expertise_proofs,
    ca.identity_proof,
    ca.initial_submission,
    ca.status,
    ca.created_at,
    ca.reviewed_at,
    ca.reviewed_by,
    u.name AS name,
    m.name AS reviewer_name
FROM contributor_applications ca
JOIN users u ON ca.user_id = u.user_id
LEFT JOIN moderators m ON ca.reviewed_by = m.moderator_id
ORDER BY ca.created_at DESC
`

type ListContributorApplicationsRow struct {
	ContriAppID       uuid.UUID
	UserID            uuid.UUID
	ExpertiseProofs   []string
	IdentityProof     string
	InitialSubmission string
	Status            sql.NullString
	CreatedAt         sql.NullTime
	ReviewedAt        sql.NullTime
	ReviewedBy        uuid.NullUUID
	Name              string
	ReviewerName      sql.NullString
}

func (q *Queries) ListContributorApplications(ctx context.Context) ([]ListContributorApplicationsRow, error) {
	rows, err := q.db.QueryContext(ctx, listContributorApplications)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListContributorApplicationsRow
	for rows.Next() {
		var i ListContributorApplicationsRow
		if err := rows.Scan(
			&i.ContriAppID,
			&i.UserID,
			pq.Array(&i.ExpertiseProofs),
			&i.IdentityProof,
			&i.InitialSubmission,
			&i.Status,
			&i.CreatedAt,
			&i.ReviewedAt,
			&i.ReviewedBy,
			&i.Name,
			&i.ReviewerName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateContributorApplication = `-- name: UpdateContributorApplication :one
UPDATE contributor_applications
SET
    status = $2,
    reviewed_at = CURRENT_TIMESTAMP,
    reviewed_by = $3
WHERE contri_app_id = $1
RETURNING contri_app_id, user_id, expertise_proofs, identity_proof, initial_submission, status, created_at, reviewed_at
`

type UpdateContributorApplicationParams struct {
	ContriAppID uuid.UUID
	Status      sql.NullString
	ReviewedBy  uuid.NullUUID
}

type UpdateContributorApplicationRow struct {
	ContriAppID       uuid.UUID
	UserID            uuid.UUID
	ExpertiseProofs   []string
	IdentityProof     string
	InitialSubmission string
	Status            sql.NullString
	CreatedAt         sql.NullTime
	ReviewedAt        sql.NullTime
}

func (q *Queries) UpdateContributorApplication(ctx context.Context, arg UpdateContributorApplicationParams) (UpdateContributorApplicationRow, error) {
	row := q.db.QueryRowContext(ctx, updateContributorApplication, arg.ContriAppID, arg.Status, arg.ReviewedBy)
	var i UpdateContributorApplicationRow
	err := row.Scan(
		&i.ContriAppID,
		&i.UserID,
		pq.Array(&i.ExpertiseProofs),
		&i.IdentityProof,
		&i.InitialSubmission,
		&i.Status,
		&i.CreatedAt,
		&i.ReviewedAt,
	)
	return i, err
}
